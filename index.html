<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RRDB Reactors Timeline Map</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- D3 (for collision layout + criticality chart) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #app { height: 100%; display: grid; grid-template-rows: 1fr auto; }

    #mapWrap { position: relative; }
    #map { height: 100%; width: 100%; z-index: 1; }

    /* Bottom controls */
    #controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      padding: 10px 12px;
      border-top: 1px solid #e6e6e6;
      background: #fff;
      align-items: center;
    }
    #timeline {
      display: grid;
      grid-template-columns: auto auto 1fr auto;
      gap: 10px;
      align-items: center;
    }
    button {
      border: 1px solid #ddd;
      background: #fafafa;
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
    }
    button:hover { background: #f2f2f2; }
    #yearLabel { font-variant-numeric: tabular-nums; font-weight: 600; width: 70px; text-align: right; }
    input[type="range"] { width: 100%; }

    /* Legend */
    #legend {
      z-index: 2001;
      position: absolute;
      left: 12px;
      bottom: 12px;
      background: rgba(255,255,255,0.95);
      border: 1px solid #e6e6e6;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      backdrop-filter: blur(6px);
      font-size: 13px;
      line-height: 1.3;
      pointer-events: auto;
      user-select: none;
      min-width: 220px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      cursor: pointer;
      margin: 4px 0;
      opacity: 0.55;
    }
    .legend-item.active { opacity: 1; font-weight: 650; }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
      border: 1px solid rgba(0,0,0,0.15);
    }

    /* Criticality chart overlay */
    #crit-chart {
      position: absolute;
      right: 12px;
      bottom: 12px;
      width: 390px;
      height: 250px;
      background: rgba(255,255,255,0.95);
      border-radius: 12px;
      padding: 8px 10px;
      z-index: 2001;
      pointer-events: auto;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      backdrop-filter: blur(6px);
    }
    #crit-chart svg text { fill: #111; }
  </style>
</head>

<body>
<div id="app">
  <div id="mapWrap">
    <div id="map"></div>

    <div id="crit-chart"></div>

    <div id="legend">
      <div class="legend-item active" data-status="all">
        <span class="legend-dot" style="background:#666"></span> All
      </div>
      <div class="legend-item" data-status="construction">
        <span class="legend-dot" style="background:#6ec6ff"></span> Under construction
      </div>
      <div class="legend-item" data-status="operational">
        <span class="legend-dot" style="background:#34c759"></span> Operational
      </div>
      <div class="legend-item" data-status="extended">
        <span class="legend-dot" style="background:#ff9f0a"></span> Extended shutdown
      </div>
      <div class="legend-item" data-status="shutdown">
        <span class="legend-dot" style="background:#ff3b30"></span> Shutdown / Decommissioned
      </div>
    </div>
  </div>

  <div id="controls">
    <div id="timeline">
      <button id="playBtn">Play</button>
      <button id="pauseBtn" disabled>Pause</button>
      <input id="yearSlider" type="range" min="1950" max="2026" step="1" value="2000">
      <div id="yearLabel">2000</div>
    </div>

    <div style="text-align:right; font-size:12px; color:#666;">
      Data: <code id="dataStatus">loading…</code>
    </div>
  </div>
</div>

<script>
/**
 * Files expected next to index.html:
 * - reactors.json
 * - geocodes.json
 */
const DATA_URL = "reactors.json";
const GEO_URL  = "geocodes.json";

const FINAL_YEAR = 2026;

// ----------------------------
// State
// ----------------------------
let REACTORS = [];
let GEO = new Map();      // cityKey -> {lat, lon}
let MARKERS = new Map();  // iaea_code -> Leaflet marker
let PLAY_TIMER = null;
let STATUS_FILTER = "all";

// ----------------------------
// Colors + status mapping
// ----------------------------
const COLORS = {
  construction: "#6ec6ff",
  operational:  "#34c759",
  extended:     "#ff9f0a",
  shutdown:     "#ff3b30"
};

const STATUS_SHUTDOWN_SET = new Set([
  "PERMANENT SHUTDOWN",
  "UNDER DECOMMISSIONING",
  "DECOMMISSIONED",
]);

function normStatus(s) {
  return (s || "").toUpperCase().trim().replace(/\s+/g, " ");
}

function isShutdownByStatus(r) {
  return STATUS_SHUTDOWN_SET.has(normStatus(r.status));
}

function isExtendedShutdown(statusText) {
  const s = normStatus(statusText);
  // (best-effort: adjust if you want)
  return s.includes("EXTENDED") || s.includes("TEMPORARY") || s.includes("TEMP") || s === "EXTENDED SHUTDOWN";
}

// ----------------------------
// Parsing helpers
// ----------------------------
function parseYearLoose(s) {
  if (!s) return null;
  const str = String(s).trim();
  if (!str) return null;

  const m1 = str.match(/\b(19\d{2}|20\d{2})\b/);
  if (m1) return Number(m1[1]);

  const m2 = str.match(/(\d{1,2})[./-](\d{1,2})[./-](\d{2,4})/);
  if (m2) {
    let y = m2[3];
    if (y.length === 2) y = "20" + y;
    return Number(y);
  }

  const m3 = str.match(/(19\d{2}|20\d{2})[./-]\d{1,2}[./-]\d{1,2}/);
  if (m3) return Number(m3[1]);

  return null;
}

function cityKey(r) {
  const city = (r.location_closest_city || "").trim().toLowerCase();
  const country = (r.country || "").trim().toLowerCase();
  return `${city}|${country}`;
}

function escapeHtml(s) {
  return String(s || "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}

function makePopup(r, state, year) {
  return [
    `<b>${escapeHtml(r.name || "")}</b>`,
    `<div><code>${escapeHtml(r.iaea_code || "")}</code></div>`,
    `<div>${escapeHtml(r.location_closest_city || "")}, ${escapeHtml(r.country || "")}</div>`,
    `<div>Status@${year}: <b>${escapeHtml(state)}</b></div>`,
    `<hr style="border:none;border-top:1px solid #eee;margin:8px 0;">`,
    `<div>Start construction: ${escapeHtml(r.start_of_construction || "")}</div>`,
    `<div>First criticality: ${escapeHtml(r.first_criticality || "")}</div>`,
    `<div>Temp shutdown: ${escapeHtml(r.tmp_shutdown_date || "")}</div>`,
    `<div>Shutdown: ${escapeHtml(r.shutdown_date || "")}</div>`,
  ].join("");
}

function markerStyleForState(state) {
  const color = COLORS[state] || "#999";
  return {
    radius: 6,
    color: "rgba(0,0,0,0.25)",
    weight: 1,
    fillColor: color,
    fillOpacity: 0.95
  };
}

// ----------------------------
// Reactor state timeline logic
// ----------------------------
function reactorStateAtYear(r, year) {
  const yConstr = parseYearLoose(r.start_of_construction);
  const yCrit   = parseYearLoose(r.first_criticality);
  const yTmp    = parseYearLoose(r.tmp_shutdown_date);
  const yShut   = parseYearLoose(r.shutdown_date);

  // If it has no "existence" by dates, don't show it at all.
  const existsByDates =
    (yConstr !== null && year >= yConstr) ||
    (yCrit   !== null && year >= yCrit);

  if (!existsByDates) {
    // But: at final snapshot year, allow shutdown-by-status to appear IF reactor exists at all in dataset?
    // You asked: only mark shutdown at 2026 when date missing.
    // Still, we keep "not shown before construction/criticality".
    return "none";
  }

  // Known shutdown date
  if (yShut !== null && year >= yShut) return "shutdown";

  // Unknown shutdown date but status says shutdown/decom -> treat as shutdown only at FINAL_YEAR snapshot
  if (year >= FINAL_YEAR && isShutdownByStatus(r)) return "shutdown";

  // Extended shutdown
  if ((yTmp !== null && year >= yTmp) || isExtendedShutdown(r.status)) {
    // prefer operational if it clearly has criticality and tmp is missing/stale
    if (yCrit !== null && year >= yCrit) {
      if (yTmp === null) return "operational";
      if (yTmp !== null && yTmp > yCrit && year >= yTmp) return "extended";
      return "operational";
    }
    if (yTmp !== null && year >= yTmp) return "extended";
    if (isExtendedShutdown(r.status)) return "extended";
  }

  // Operational
  if (yCrit !== null && year >= yCrit) return "operational";

  // Construction
  if (yConstr !== null && year >= yConstr) return "construction";

  return "none";
}

// ----------------------------
// Leaflet map init
// ----------------------------
const map = L.map("map", { preferCanvas: true }).setView([20, 0], 2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 18,
  attribution: "&copy; OpenStreetMap contributors"
}).addTo(map);

// ----------------------------
// Global collision layout (pixel-space)
// ----------------------------
const MARKER_RADIUS_PX = 6;
const MARKER_GAP_PX = 0;                 // allow touching
const COLLISION_R_PX = MARKER_RADIUS_PX + MARKER_GAP_PX;
const SIM_ITERS = 80;

function computeGlobalCollisionLatLngs(visibleReactors) {
  const nodes = [];
  for (const r of visibleReactors) {
    const geo = GEO.get(cityKey(r));
    if (!geo) continue;

    const baseLatLng = L.latLng(geo.lat, geo.lon);
    const anchor = map.latLngToLayerPoint(baseLatLng);

    nodes.push({
      id: r.iaea_code,
      ax: anchor.x,
      ay: anchor.y,
      x: anchor.x,
      y: anchor.y
    });
  }

  const sim = d3.forceSimulation(nodes)
    .force("x", d3.forceX(d => d.ax).strength(0.65))
    .force("y", d3.forceY(d => d.ay).strength(0.65))
    .force("collide", d3.forceCollide(COLLISION_R_PX).iterations(2))
    .stop();

  for (let t = 0; t < SIM_ITERS; t++) sim.tick();

  const out = new Map();
  for (const n of nodes) out.set(n.id, map.layerPointToLatLng(L.point(n.x, n.y)));
  return out;
}

// re-layout on zoom/pan
let relayoutTimer = null;
function scheduleRelayout() {
  clearTimeout(relayoutTimer);
  relayoutTimer = setTimeout(() => {
    renderYear(Number(yearSlider.value), { fromMapEvent: true });
  }, 80);
}
map.on("zoomend moveend", scheduleRelayout);

// ----------------------------
// Criticality chart (D3) — integral + differential
// ----------------------------
let MIN_YEAR = 1950;
let CRIT_SERIES = null;
let critSvg, critG, critX, critYLeft, critYRight, critLinePath, critBarsG, critXAxisG, critYLeftG, critYRightG;
let critInnerH = 0, critInnerW = 0;

function buildCriticalitySeries(reactors, minYear, maxYear) {
  const yearly = new Map();
  for (let y = minYear; y <= maxYear; y++) yearly.set(y, 0);

  for (const r of reactors) {
    const yCrit = parseYearLoose(r.first_criticality);
    if (yCrit !== null && yCrit >= minYear && yCrit <= maxYear) {
      yearly.set(yCrit, (yearly.get(yCrit) || 0) + 1);
    }
  }

  let cum = 0;
  const series = [];
  for (let y = minYear; y <= maxYear; y++) {
    const inc = yearly.get(y) || 0;
    cum += inc;
    series.push({ year: y, inc, cum });
  }
  return series;
}

function initCriticalityChart() {
  const el = document.getElementById("crit-chart");
  el.innerHTML = "";

  const W = 380, H = 240;
  const M = { top: 22, right: 52, bottom: 28, left: 52 };
  const iw = W - M.left - M.right;
  const ih = H - M.top - M.bottom;
  critInnerW = iw;
  critInnerH = ih;

  CRIT_SERIES = buildCriticalitySeries(REACTORS, MIN_YEAR, FINAL_YEAR);

  critSvg = d3.select(el).append("svg").attr("width", W).attr("height", H);
  critSvg.append("text")
    .attr("x", 10).attr("y", 16)
    .attr("font-size", 12).attr("font-weight", 650)
    

  critG = critSvg.append("g").attr("transform", `translate(${M.left},${M.top})`);

  critX = d3.scaleLinear().domain([MIN_YEAR, FINAL_YEAR]).range([0, iw]);
  critYLeft  = d3.scaleLinear().domain([0, d3.max(CRIT_SERIES, d => d.cum) || 1]).nice().range([ih, 0]);
  critYRight = d3.scaleLinear().domain([0, d3.max(CRIT_SERIES, d => d.inc) || 1]).nice().range([ih, 0]);

  critXAxisG  = critG.append("g").attr("transform", `translate(0,${ih})`);
  critYLeftG  = critG.append("g");
  critYRightG = critG.append("g").attr("transform", `translate(${iw},0)`);

  critXAxisG.call(d3.axisBottom(critX).ticks(6).tickFormat(d3.format("d")));
  critYLeftG.call(d3.axisLeft(critYLeft).ticks(5));
  critYRightG.call(d3.axisRight(critYRight).ticks(5));

  critYRightG.selectAll("text")
    .attr("fill", "rgba(80,120,255,1)");   // choose your color
  
  critYRightG.selectAll("line")
    .attr("stroke", "rgba(80,120,255,1)");
  
  critYRightG.selectAll("path")
    .attr("stroke", "rgba(80,120,255,1)");
  // bars + line layers
  critBarsG = critG.append("g");
  critLinePath = critG.append("path")
    .attr("fill", "none")
    .attr("stroke", "#111")           // IMPORTANT: otherwise invisible
    .attr("stroke-opacity", 0.85)
    .attr("stroke-width", 2);

  // vertical year line
  critG.append("line")
    .attr("id", "crit-year-line")
    .attr("y1", 0).attr("y2", ih)
    .attr("stroke", "rgba(0,0,0,0.45)")
    .attr("stroke-width", 1)
    .attr("stroke-dasharray", "4,4");

  // legend (top-left, under title)
  const leg = critSvg.append("g")
    .attr("transform", "translate(14,32)");

  leg.append("rect")
    .attr("x", 0).attr("y", -23)
    .attr("width", 10).attr("height", 10)
    .attr("fill", "rgba(80,120,255,0.55)");

  leg.append("text")
    .attr("x", 14).attr("y", -15)
    .attr("font-size", 11)
    .text("New criticalities / year");

  leg.append("line")
    .attr("x1", 190).attr("x2", 205)
    .attr("y1", -19).attr("y2", -19)
    .attr("stroke", "#111")
    .attr("stroke-width", 2);

  leg.append("text")
    .attr("x", 210).attr("y", -15)
    .attr("font-size", 11)
    .text("Cumulative");
}

function updateCriticalityChartToYear(year) {
  if (!CRIT_SERIES) return;

  const data = CRIT_SERIES.filter(d => d.year <= year);

  const step = critX(MIN_YEAR + 1) - critX(MIN_YEAR);
  const bw = Math.max(1, step * 0.85);

  const bars = critBarsG.selectAll("rect").data(data, d => d.year);

  bars.enter().append("rect")
      .attr("fill", "rgba(80,120,255,0.55)")
      .attr("x", d => critX(d.year) - bw/2)
      .attr("width", bw)
      .attr("y", d => critYRight(d.inc))
      .attr("height", d => critYRight(0) - critYRight(d.inc))
    .merge(bars)
      .attr("x", d => critX(d.year) - bw/2)
      .attr("width", bw)
      .attr("y", d => critYRight(d.inc))
      .attr("height", d => critYRight(0) - critYRight(d.inc));

  bars.exit().remove();

  const line = d3.line()
    .x(d => critX(d.year))
    .y(d => critYLeft(d.cum));

  critLinePath.datum(data).attr("d", line);

  critG.select("#crit-year-line")
    .attr("x1", critX(year))
    .attr("x2", critX(year));
}

// ----------------------------
// Render year (map + chart)
// ----------------------------
function renderYear(year, opts = {}) {
  if (!opts.fromMapEvent) {
    yearSlider.value = year;
    yearLabel.textContent = year;
  }
  if (!REACTORS || REACTORS.length === 0) return;
  if (!(GEO instanceof Map) || GEO.size === 0) return;

  // Visible reactors for this year (before filter)
  const visible = [];
  for (const r of REACTORS) {
    const st = reactorStateAtYear(r, year);
    if (st !== "none") visible.push(r);
  }

  // Compute global collision positions
  const collisionLatLngs = computeGlobalCollisionLatLngs(visible);

  // Add/update/remove markers
  for (const r of REACTORS) {
    const state = reactorStateAtYear(r, year);
    const marker = MARKERS.get(r.iaea_code);

    // Hide if not existing by dates
    if (state === "none") {
      if (marker) { map.removeLayer(marker); MARKERS.delete(r.iaea_code); }
      continue;
    }

    // Apply legend filter
    if (STATUS_FILTER !== "all" && state !== STATUS_FILTER) {
      if (marker) { map.removeLayer(marker); MARKERS.delete(r.iaea_code); }
      continue;
    }

    const ll = collisionLatLngs.get(r.iaea_code);
    if (!ll) {
      if (marker) { map.removeLayer(marker); MARKERS.delete(r.iaea_code); }
      continue;
    }

    const style = markerStyleForState(state);
    if (!marker) {
      const m = L.circleMarker(ll, style).bindPopup(makePopup(r, state, year));
      m.addTo(map);
      MARKERS.set(r.iaea_code, m);
    } else {
      marker.setLatLng(ll);
      marker.setStyle(style);
      marker.setPopupContent(makePopup(r, state, year));
    }
  }

  updateCriticalityChartToYear(year);
}

// ----------------------------
// Controls
// ----------------------------
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");
const yearSlider = document.getElementById("yearSlider");
const yearLabel = document.getElementById("yearLabel");
const dataStatus = document.getElementById("dataStatus");

function setPlaying(isPlaying) {
  playBtn.disabled = isPlaying;
  pauseBtn.disabled = !isPlaying;
}

function startPlay() {
  if (PLAY_TIMER) return;
  setPlaying(true);
  PLAY_TIMER = setInterval(() => {
    const y = Number(yearSlider.value);
    const maxY = Number(yearSlider.max);
    const next = (y >= maxY) ? Number(yearSlider.min) : y + 1;
    renderYear(next);
  }, 450);
}

function stopPlay() {
  setPlaying(false);
  if (PLAY_TIMER) clearInterval(PLAY_TIMER);
  PLAY_TIMER = null;
}

playBtn.addEventListener("click", startPlay);
pauseBtn.addEventListener("click", stopPlay);
yearSlider.addEventListener("input", (e) => {
  stopPlay();
  renderYear(Number(e.target.value));
});

// Legend click filter
document.querySelectorAll("#legend .legend-item").forEach(item => {
  item.addEventListener("click", () => {
    STATUS_FILTER = item.dataset.status;

    document.querySelectorAll("#legend .legend-item").forEach(el => el.classList.remove("active"));
    item.classList.add("active");

    renderYear(Number(yearSlider.value));
  });
});

// ----------------------------
// Load + boot
// ----------------------------
async function loadJson(url) {
  const resp = await fetch(url, { cache: "no-store" });
  if (!resp.ok) throw new Error(`Failed to load ${url} (${resp.status})`);
  return await resp.json();
}

function computeMinYearFromDates(reactors) {
  const years = [];
  for (const r of reactors) {
    for (const k of ["start_of_construction","first_criticality","tmp_shutdown_date","shutdown_date"]) {
      const y = parseYearLoose(r[k]);
      if (y !== null) years.push(y);
    }
  }
  return years.length ? Math.min(...years) : 1950;
}

(async function boot() {
  try {
    dataStatus.textContent = "loading reactors.json…";
    REACTORS = await loadJson(DATA_URL);
    dataStatus.textContent = `${REACTORS.length} reactors loaded`;

    MIN_YEAR = computeMinYearFromDates(REACTORS);

    yearSlider.min = String(MIN_YEAR);
    yearSlider.max = String(FINAL_YEAR);
    const initial = Math.max(MIN_YEAR, Math.min(FINAL_YEAR, Number(yearSlider.value || 2000)));
    yearSlider.value = String(initial);
    yearLabel.textContent = yearSlider.value;

    dataStatus.textContent = "loading geocodes.json…";
    const geoObj = await loadJson(GEO_URL);
    GEO = new Map(Object.entries(geoObj));
    dataStatus.textContent = `ready (geocodes: ${GEO.size})`;

    // init chart AFTER data is loaded
    initCriticalityChart();
    updateCriticalityChartToYear(Number(yearSlider.value));

    // initial render
    renderYear(Number(yearSlider.value));
  } catch (e) {
    console.error(e);
    dataStatus.textContent = "ERROR (see console)";
  }
})();
</script>
</body>
</html>
